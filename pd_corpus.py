from sparql import DB
from corpus import Corpus
from pd_poem import PostdataPoem
from util import shorthash
from pd_stardog_queries import PoeticWorkUris, CountPoeticWorks, CountAuthors, CountStanzas, CountVerses, CountWords, \
    CountMetricalSyllables, CountGrammaticalSyllables


class PostdataCorpus(Corpus):
    """POSTDATA Corpus

    Attributes:
        database (DB): Database Connection
        poem_uris(list): URIs of poems in the corpus.
        poems (dict): Poems of a corpus. Dictionary key is a poem ID, value an instance of PostdataPoem.
    """
    name = "postdata"

    # Title of the Corpus
    title = "POSTDATA Corpus"

    # Description of the Corpus
    description = """POSTDATA Knowledge Graph of Poetry. See https://postdata.linhd.uned.es"""

    # Database connection
    database = None

    # URIs of poems
    poem_uris = None

    # To look-up poem IDs (dict)
    __poem_ids = None

    # Poems of a corpus. Dictionary with instances of PostdataPoem
    poems = None

    def __init__(self, database: DB = None):
        """

        Args:
            database: connection to a triple store. Use instance of class DB.

        TODO: maybe do not hardcode the queries (using the classes) but initialize with instances derived from them.
        """
        if database:
            self.database = database

        # SPARQL Queries:
        # different queries (e.g. for different triple store setup) could be set here. Just an idea..
        # The classes are initialized here, because if only inside the class, new instances remember the query.
        # TODO: check, if there is an option to initialize them when they are actually needed

        # URIs of Poems – used in: get_poem_uris()
        self.sparql_poem_uris = PoeticWorkUris()
        # Count Poems – used in: get_num_poems()
        self.sparql_num_poems = CountPoeticWorks()
        # Count Authors – used in: get_num_authors()
        self.sparql_num_authors = CountAuthors()
        # Count Stanzas – used in: get_num_stanzas()
        self.sparql_num_stanzas = CountStanzas()
        # Count Verses – used in: get_num_verses()
        self.sparql_num_verses = CountVerses()
        # Count Words – used in: get_num_words()
        self.sparql_num_words = CountWords()
        # Count Grammatical Syllables – used in get_num_grammatical_syllables()
        self.sparql_num_grammatical_syllables = CountGrammaticalSyllables()
        # Count Metrical Syllables – used in: get_num_metrical_syllables()
        self.sparql_num_metrical_syllables = CountMetricalSyllables()

    def get_poem_uris(self) -> list:
        """Get a list of URIs of instances of the class pdc:PoeticWork.

        Uses a SPARQL Query of class "PoeticWorkUris" of the module "pd_stardog_queries".

        Returns:
            list: URIs of instances of class pdc:PoeticWork

        """
        # check, if the poem uris have already been loaded, no need to load them again
        if self.poem_uris:
            return self.poem_uris
        else:
            if self.database:
                # A database connection has been established:
                # Use the SPARQL Query of class "PoeticWorkUris" (set as attribute of this class)
                # execute the SPARQL Query against the database and simplify the results (will be a list of uris)
                self.sparql_poem_uris.execute(self.database)
                self.poem_uris = self.sparql_poem_uris.results.simplify()
                return self.poem_uris
            else:
                raise Exception("Database Connection not available.")

    def __generate_poem_id_by_poem_uri(self, poem_uri) -> str:
        """Helper method to generate a id for a pome

        Create a md5 hash and trunctate it. This is handled by the shorthash function from the util module.
        Attention: This is aligned to poem class' private method "__generate_id_by_uri()". Make sure, they stay in sync.

        Args:
            poem_uri: URI of a poem in the corpus.

        Returns:
            str: ID of a Poem.
        """
        return shorthash(poem_uri)

    def __prepare_poem_id_lookup(self) -> bool:
        """Helper Method to create a dictionary to look-up poem ids.

        IDs of poems are trunctaded md5 hashes generated by poem class' private method "__generate_id_by_uri()"
        (uses util:shorthash with the default value for "chars"=8).

        Returns:
            bool: True if successful.

        """
        if self.__poem_ids:
            # already created
            return True
        else:
            # need to create this
            self.__poem_ids = dict()

            if self.poem_uris:
                pass
            else:
                # need to get the poem uris first
                self.get_poem_uris()

            for poem_uri in self.poem_uris:
                poem_id = self.__generate_poem_id_by_poem_uri(poem_uri)
                self.__poem_ids[poem_id] = poem_uri

            return True

    def get_poem_uri_by_id(self, poem_id: str) -> str:
        """Look up a full poem uri by its id.

        The ID of the poem is a trunctated md5 hash of the URI. __poem_ids provide a dictionary that allows for lookups.

        Args:
            poem_id (str): ID of a poem.

        Returns:
            str: URI of the poem.
        """
        if self.__prepare_poem_id_lookup() is True:
            if poem_id in self.__poem_ids:
                return self.__poem_ids[poem_id]
            else:
                return None

    def get_num_poems(self) -> int:
        """Count poems in corpus.

        Uses a SPARQL Query of class "CountPoeticWorks" of the module "pd_stardog_queries".

        Returns:
            int: Number of poems.
        """
        if self.num_poems:
            return self.num_poems
        else:
            if self.database:
                # Use the SPARQL Query of class "CountPoeticWorks" (set as attribute of this class)
                self.sparql_num_poems.execute(self.database)
                # normally, the result would be a list containing a single string value
                # by supplying a mapping to the simplify method the value bound to the variable "count"
                # can be cast to an integer
                mapping = {"count": {"datatype": "int"}}
                self.num_poems = self.sparql_num_poems.results.simplify(mapping=mapping)[0]
                return self.num_poems
            else:
                raise Exception("Database Connection not available.")

    def get_num_authors(self) -> int:
        """Count authors of poems in a corpus.

        Uses a SPARQL Query of class "CountAuthors" of the module "pd_stardog_queries".

        Returns:
            int: Number of authors.
        """
        if self.num_authors:
            return self.num_authors
        else:
            if self.database:
                # Use the SPARQL Query of class "CountAuthors" (set as attribute of this class)
                self.sparql_num_authors.execute(self.database)
                # normally, the result would be a list containing a single string value
                # by supplying a mapping to the simplify method the value bound to the variable "count"
                # can be cast to an integer
                mapping = {"count": {"datatype": "int"}}
                self.num_authors = self.sparql_num_authors.results.simplify(mapping=mapping)[0]
                return self.num_authors
            else:
                raise Exception("Database Connection not available.")

    def get_num_stanzas(self) -> int:
        """Count stanzas in a corpus.

        Uses a SPARQL Query of class "CountStanzas" of the module "pd_stardog_queries".

        Returns:
            int: Number of stanzas.
        """
        if self.num_stanzas:
            return self.num_stanzas
        else:
            if self.database:
                # Use the SPARQL Query of class "CountStanzas" (set as attribute of this class)
                self.sparql_num_stanzas.execute(self.database)
                # normally, the result would be a list containing a single string value
                # by supplying a mapping to the simplify method the value bound to the variable "count"
                # can be cast to an integer
                mapping = {"count": {"datatype": "int"}}
                self.num_stanzas = self.sparql_num_stanzas.results.simplify(mapping=mapping)[0]
                return self.num_stanzas
            else:
                raise Exception("Database Connection not available.")

    def get_num_verses(self) -> int:
        """Count verses in a corpus.

        Uses a SPARQL Query of class "CountVerses" of the module "pd_stardog_queries".

        Returns:
            int: Number of verse lines.
        """
        if self.num_verses:
            return self.num_verses
        else:
            if self.database:
                # Use the SPARQL Query of class "CountVerses" (set as attribute of this class)
                self.sparql_num_verses.execute(self.database)
                # normally, the result would be a list containing a single string value
                # by supplying a mapping to the simplify method the value bound to the variable "count"
                # can be cast to an integer
                mapping = {"count": {"datatype": "int"}}
                self.num_verses = self.sparql_num_verses.results.simplify(mapping=mapping)[0]
                return self.num_verses
            else:
                raise Exception("Database Connection not available.")

    def get_num_words(self) -> int:
        """Count words in a corpus.

        Uses a SPARQL Query of class "CountWords" of the module "pd_stardog_queries".

        Returns:
            int: Number of words.
        """
        if self.num_words:
            return self.num_words
        else:
            if self.database:
                # Use the SPARQL Query of class "CountWords" (set as attribute of this class)
                self.sparql_num_words.execute(self.database)
                # normally, the result would be a list containing a single string value
                # by supplying a mapping to the simplify method the value bound to the variable "count"
                # can be cast to an integer
                mapping = {"count": {"datatype": "int"}}
                self.num_words = self.sparql_num_words.results.simplify(mapping=mapping)[0]
                return self.num_words
            else:
                raise Exception("Database Connection not available.")

    def get_num_grammatical_syllables(self) -> int:
        """Count grammatical syllables in a corpus.

        Uses a SPARQL Query of class "CountGrammaticalSyllables" of the module "pd_stardog_queries".

        Returns:
            int: Number of grammatical syllables.
        """
        if self.num_grammatical_syllables:
            return self.num_grammatical_syllables
        else:
            if self.database:
                # Use the SPARQL Query of class "CountGrammaticalSyllables" (set as attribute of this class)
                self.sparql_num_grammatical_syllables.execute(self.database)
                # normally, the result would be a list containing a single string value
                # by supplying a mapping to the simplify method the value bound to the variable "count"
                # can be cast to an integer
                mapping = {"count": {"datatype": "int"}}
                self.num_grammatical_syllables = self.sparql_num_grammatical_syllables.results.simplify(mapping=mapping)[0]
                return self.num_grammatical_syllables
            else:
                raise Exception("Database Connection not available.")

    def get_num_metrical_syllables(self) -> int:
        """Count metrical syllables in a corpus.

        Uses a SPARQL Query of class "CountMetricalSyllables" of the module "pd_stardog_queries".

        Returns:
            int: Number of metrical syllables.

        """
        if self.num_metrical_syllables:
            return self.num_metrical_syllables
        else:
            if self.database:
                # Use the SPARQL Query of class "CountMetricalSyllables" (set as attribute of this class)
                self.sparql_num_metrical_syllables.execute(self.database)
                # normally, the result would be a list containing a single string value
                # by supplying a mapping to the simplify method the value bound to the variable "count"
                # can be cast to an integer
                mapping = {"count": {"datatype": "int"}}
                self.num_metrical_syllables = self.sparql_num_metrical_syllables.results.simplify(mapping=mapping)[0]
                return self.num_metrical_syllables
            else:
                raise Exception("Database Connection not available.")

    def get_metrics(self) -> dict:
        """Assemble and return corpus metrics.

        Will return metrics for "poems", "authors", "stanzas", "verses", "words", "grammatical syllables" and "metrical"
        syllables.

        Returns:
            dict: Corpus metrics.
        """
        metrics = dict(
            poems=self.get_num_poems(),
            authors=self.get_num_authors(),
            stanzas=self.get_num_stanzas(),
            verses=self.get_num_verses(),
            words=self.get_num_words(),
            grammaticalSyllables=self.get_num_grammatical_syllables(),
            metricalSyllables=self.get_num_metrical_syllables(),
        )

        return metrics

    def get_metadata(self, include_metrics: bool = False) -> dict:
        """Serialize Corpus Metadata.

        Args:
            include_metrics (bool, optional): Include metrics. Defaults to False.

        Returns:
            dict: Serialization of the corpus metadata.
        """
        metadata = dict(
            name=self.name,
            title=self.title,
            description=self.description
        )

        if include_metrics is True:
            metadata["metrics"] = self.get_metrics()

        return metadata

    def get_uri_set(self, limit: int = 500, offset: int = 0) -> list:
        """Get a set of uris.

        Args:
            limit (int): Number of URIs to include in a set.
            offset (int): position to start at.

        Returns:
            list: Set of uris.
        """
        if self.poem_uris:
            pass
        else:
            self.get_poem_uris()
        # TODO: not sure about this limit + offset thing
        return self.poem_uris[offset:offset + limit]

    def load_poem(self, id: str = None, uri:str = None) -> bool:
        """Load a poem of the corpus.

        Either "id" or "uri" must be supplied as keyword argument. Will add an instance of PostdataPoem to self.poems
        while the key will be the Poem ID "id".

        Args:
            id (str, optional): Poem ID.
            uri (str, optional): URI of the Poem.

        Returns:
            bool: True if successful
        """
        if id or uri:

            if id:
                poem_id = id
            else:
                poem_id = self.__generate_poem_id_by_poem_uri(uri)

            if uri:
                poem_uri = uri
            else:
                poem_uri = self.get_poem_uri_by_id(id)

            if poem_id and poem_uri:

                # need to check if there are already loaded poems, if not, create a dictionary to hold the poems
                if self.poems:
                    pass
                else:
                    self.poems = dict()

                if poem_id in self.poems:
                    # already loaded
                    return True
                else:
                    # not loaded, need to initialize a new poem and add to poem
                    # need to have a database connection
                    if self.database:
                        poem = PostdataPoem(uri=poem_uri, database=self.database)
                        self.poems[poem_id] = poem
                        return True
                    else:
                        raise Exception("Can not load poem. No database connection.")
        else:
            raise Exception("Either ID or URI of a poem must be supplied!")

    def load_poem_set(self, limit: int = 500, offset: int = 0) -> bool:
        """Load a set of poems.

        Depending on "self.poem_uris" a set of poems will be loaded using the method "load_poem".

        Args:
            limit (int): Number of poems to load.
            offset (int): position to start at (in the list of poem_uris).

        Returns:
            bool: True if operation ran through. Need to check if all poems are loaded.
        """
        uri_set = self.get_uri_set(limit=limit, offset=offset)
        for poem_uri in uri_set:
            self.load_poem(uri=poem_uri)
        # TODO: Maybe implement better error handling or a check if poems were loaded at all.
        return True

    def load_poems(self) -> bool:
        """Load all poems.

        Returns:
            bool: True if operation ran through. Need to check if all poems are loaded.
        """
        if self.poem_uris:
            pass
        else:
            self.get_poem_uris()

        for poem_uri in self.poem_uris:
            self.load_poem(uri=poem_uri)
        return True

    def get_metadata_of_poem_set(self, limit: int = 500, offset: int = 0, include_authors: bool = False) -> list:
        """Serialize Metadata of a set of included poems

        Args:
            limit (int): Number of poems to include.
            offset (int): position to start at (in the list of poem_uris).
            include_authors (bool, optional): Include information on author in single poem metadata item.

        Returns:
            list: Metadata on poems.
        TODO: This is slow, maybe find ways to optimize.
        """
        set_metadata = list()
        set_uris = self.get_uri_set(limit=limit, offset=offset)
        for poem_uri in set_uris:
            # load the poem: will not load second time, if already there
            self.load_poem(uri=poem_uri)
            # need the id to address it
            poem_id = self.__generate_poem_id_by_poem_uri(poem_uri)
            if poem_id in self.poems:
                poem_metadata = self.poems[poem_id].get_metadata(include_authors=include_authors)
                set_metadata.append(poem_metadata)
        return set_metadata
